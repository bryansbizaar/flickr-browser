#!/usr/bin/env python3
"""
Fixed Incremental Updater for Flickr Local Browser
Uses junction table schema for proper album associations
"""

import os
import json
import sys
import sqlite3
from pathlib import Path
from datetime import datetime
import time

# Add the current directory to path
sys.path.append(os.path.dirname(__file__))

try:
    from oauth_downloader import FlickrDownloaderOAuth
except ImportError:
    print("ERROR: Could not import oauth_downloader", file=sys.stderr)
    sys.exit(1)

class FixedIncrementalFlickrUpdater(FlickrDownloaderOAuth):
    """Extended downloader that only downloads new photos and uses junction table"""
    
    def __init__(self, api_key, api_secret, user_id, output_dir="data"):
        super().__init__(api_key, api_secret, user_id, output_dir)
        self.new_photos_count = 0
        self.new_associations_count = 0
        self.skipped_photos_count = 0
        self.existing_photo_ids = self.get_existing_photo_ids()
        self.ensure_junction_table()
        
    def ensure_junction_table(self):
        """Ensure the junction table exists"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS photo_albums (
                photo_id TEXT,
                album_id TEXT,
                is_primary INTEGER DEFAULT 0,
                date_added TEXT DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (photo_id, album_id),
                FOREIGN KEY (photo_id) REFERENCES photos (id),
                FOREIGN KEY (album_id) REFERENCES albums (id)
            )
        """)
        
        conn.commit()
        conn.close()
        
    def get_existing_photo_ids(self):
        """Get set of all photo IDs already in database"""
        if not self.db_path.exists():
            print("üìÑ No existing database found - this will be a full download")
            return set()
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM photos")
            existing_ids = {row[0] for row in cursor.fetchall()}
            conn.close()
            
            print(f"üìä Found {len(existing_ids)} existing photos in database")
            return existing_ids
            
        except Exception as e:
            print(f"‚ö†Ô∏è Warning: Could not read existing photos: {e}")
            return set()
    
    def photo_exists(self, photo_id):
        """Check if photo already exists in database"""
        return photo_id in self.existing_photo_ids
    
    def photo_in_album(self, photo_id, album_id):
        """Check if photo is already associated with album"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("SELECT 1 FROM photo_albums WHERE photo_id = ? AND album_id = ?", (photo_id, album_id))
        exists = cursor.fetchone() is not None
        
        conn.close()
        return exists
    
    def thumbnail_exists(self, photo_id):
        """Check if thumbnail file already exists"""
        thumbnail_dir = self.output_dir / "thumbnails"
        
        for ext in ['.jpg', '.jpeg', '.png', '.gif']:
            if (thumbnail_dir / f"{photo_id}{ext}").exists():
                return True
        
        return False
    
    def save_photo_metadata_junction(self, photo_data, album_id, thumbnail_path):
        """Save photo metadata using junction table approach"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Save photo metadata (without album_id)
        photo_id = str(photo_data['id'])
        
        # Convert tags safely
        tags = ''
        if 'tags' in photo_data:
            tags_data = photo_data['tags']
            if isinstance(tags_data, dict):
                tags = tags_data.get('_content', '')
            elif isinstance(tags_data, list):
                tags = ', '.join(str(tag) for tag in tags_data)
            else:
                tags = str(tags_data)
        
        # Extract description safely
        description = ''
        if 'description' in photo_data:
            if isinstance(photo_data['description'], dict):
                description = photo_data['description'].get('_content', '')
            else:
                description = str(photo_data['description'])
        
        # Extract title safely
        title = ''
        if 'title' in photo_data:
            if isinstance(photo_data['title'], dict):
                title = photo_data['title'].get('_content', '')
            else:
                title = str(photo_data['title'])
        
        filename = f"{photo_data['id']}.jpg"
        thumbnail_path = str(thumbnail_path) if thumbnail_path else ''
        date_taken = str(photo_data.get('datetaken', ''))
        date_uploaded = str(photo_data.get('dateupload', ''))
        views = int(photo_data.get('views', 0)) if photo_data.get('views') else 0
        url_original = str(photo_data.get('url_o', ''))
        url_thumbnail = str(photo_data.get('url_t', ''))
        
        # Insert photo without album_id
        cursor.execute("""
            INSERT OR REPLACE INTO photos 
            (id, title, description, filename, thumbnail_path, 
             date_taken, date_uploaded, views, tags, url_original, url_thumbnail)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            photo_id, title, description, filename, thumbnail_path,
            date_taken, date_uploaded, views, tags, url_original, url_thumbnail
        ))
        
        # Add album association
        cursor.execute("""
            INSERT OR IGNORE INTO photo_albums (photo_id, album_id, is_primary, date_added)
            VALUES (?, ?, 1, ?)
        """, (photo_id, album_id, datetime.now().isoformat()))
        
        conn.commit()
        conn.close()
    
    def download_photo_if_new(self, photo, album_id, album_title):
        """Download photo only if it doesn't already exist"""
        photo_id = photo['id']
        
        # Check if photo exists
        photo_exists = self.photo_exists(photo_id)
        in_album = self.photo_in_album(photo_id, album_id) if photo_exists else False
        
        if photo_exists and in_album:
            self.skipped_photos_count += 1
            return False
        
        if not photo_exists:
            print(f"üÜï Downloading new photo: {photo.get('title', 'Untitled')}")
            
            # Get detailed photo info
            photo_info = self.get_photo_info(photo_id)
            if photo_info:
                photo.update(photo_info)
            
            # Download thumbnail
            thumbnail_path = None
            thumbnail_url = photo.get('url_t')
            if thumbnail_url:
                thumbnail_path = self.download_thumbnail(photo_id, thumbnail_url)
            
            # Get comments
            comments = self.get_photo_comments(photo_id)
            self.save_comments(photo_id, comments)
            
            # Add to existing set
            self.existing_photo_ids.add(photo_id)
            self.new_photos_count += 1
        else:
            print(f"üîó Adding existing photo to album: {photo.get('title', 'Untitled')}")
            thumbnail_path = None
        
        # Save with junction table approach
        self.save_photo_metadata_junction(photo, album_id, thumbnail_path)
        
        if not in_album:
            self.new_associations_count += 1
        
        return True
    
    def update_album_incremental(self, album_id, album_title):
        """Update album with only new photos/associations"""
        print(f"üîÑ Checking album: {album_title}")
        
        # Get all photos in album from Flickr (with pagination)
        photos = self.get_album_photos(album_id)
        total_photos = len(photos)
        
        print(f"üìä Album has {total_photos} total photos")
        
        # Update album metadata
        self.save_album_metadata(album_id, album_title, "", total_photos)
        
        # Process all photos (will skip existing ones)
        album_new_count = 0
        for i, photo in enumerate(photos, 1):
            if self.download_photo_if_new(photo, album_id, album_title):
                album_new_count += 1
        
        if album_new_count > 0:
            print(f"‚úÖ Added {album_new_count} new items to album '{album_title}'")
        else:
            print(f"‚úÖ Album '{album_title}' was already up to date")
    
    def incremental_update_all(self):
        """Perform incremental update of all albums"""
        print("üöÄ Starting incremental update...")
        print("=" * 50)
        
        # Get all albums
        try:
            albums = self.get_user_albums()
            print(f"üìÅ Found {len(albums)} albums to check")
        except Exception as e:
            print(f"‚ùå Error getting albums: {e}")
            return
        
        # Update each album
        for i, album in enumerate(albums, 1):
            album_title = album['title']['_content'] if isinstance(album['title'], dict) else str(album['title'])
            print(f"\n[{i}/{len(albums)}] {album_title}")
            
            try:
                self.update_album_incremental(album['id'], album_title)
            except Exception as e:
                print(f"‚ùå Error updating album '{album_title}': {e}")
                continue
        
        # Summary
        print("\n" + "=" * 50)
        print("üìä INCREMENTAL UPDATE SUMMARY")
        print("=" * 50)
        print(f"üÜï New photos downloaded: {self.new_photos_count}")
        print(f"üîó New album associations: {self.new_associations_count}")
        print(f"‚è≠Ô∏è  Items skipped (already present): {self.skipped_photos_count}")
        print(f"üìä Total photos in database: {len(self.existing_photo_ids)}")
        
        if self.new_photos_count > 0 or self.new_associations_count > 0:
            print(f"\n‚úÖ Successfully updated your collection!")
        else:
            print("\n‚úÖ Your collection is completely up to date!")

def load_credentials():
    """Load API credentials from config file"""
    config_file = Path.home() / ".flickr_browser_config.json"
    
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config.get('api_key'), config.get('api_secret'), config.get('user_id')
        except Exception as e:
            print(f"ERROR: Could not load credentials: {e}", file=sys.stderr)
            return None, None, None
    else:
        print("ERROR: No credentials found. Run the launcher first.", file=sys.stderr)
        return None, None, None

def main():
    print("üîÑ Fixed Flickr Incremental Updater (Junction Table Compatible)")
    print("=" * 70)
    
    # Load credentials
    api_key, api_secret, user_id = load_credentials()
    
    if not all([api_key, api_secret, user_id]):
        print("‚ùå Missing API credentials")
        sys.exit(1)
    
    # Set up data directory
    data_dir = Path("data")
    data_dir.mkdir(exist_ok=True)
    
    try:
        # Create incremental updater
        print("üîó Connecting to Flickr...")
        updater = FixedIncrementalFlickrUpdater(api_key, api_secret, user_id, str(data_dir))
        
        # Check authentication
        if not updater.load_token():
            print("üîê OAuth authentication required")
            sys.exit(2)
        
        # Test authentication
        result = updater.api_call('flickr.test.login')
        
        if result.get('stat') != 'ok':
            print("‚ùå Authentication failed")
            sys.exit(1)
        
        user = result.get('user', {})
        username = user.get('username', {}).get('_content', 'Unknown')
        print(f"‚úÖ Authenticated as: {username}")
        
        # Perform incremental update
        updater.incremental_update_all()
        
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Update cancelled by user")
        sys.exit(1)
        
    except Exception as e:
        print(f"‚ùå Error during update: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
